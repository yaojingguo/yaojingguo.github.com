---
layout: post
title: "C++"
description: ""
category:
tags: []
---
{% include JB/setup %}

- [Elements of Modern C++ Style](https://herbsutter.com/elements-of-modern-c-style/)
- [C++ POD](https://stackoverflow.com/a/146454/431698)

## Tools
- [MIT 6.828 Reading materials](https://pdos.csail.mit.edu/6.828/2017/reference.html)

```
# generate i386 instructions on a x86-64 machine
gcc m32 -S
```

### Linux
- [objdump](https://sourceware.org/binutils/docs/binutils/objdump.html#objdump)
- [readelf](https://sourceware.org/binutils/docs/binutils/readelf.html)

Useful objdump options:

```
-S
--source
Display source code intermixed with disassembly, if possible. Implies -d.

-d
--disassemble
Display the assembler mnemonics for the machine instructions from objfile.
This option only disassembles those sections which are expected to contain
instructions.

-h # same as readelf -l
```

Useful readelf options:
```
-l
--program-headers
--segments
Displays the information contained in the file’s segment headers, if it has any.

--syms              Display the symbol table
-l --program-headers   Display the program headers

-S --section-headers   Display the sections' header
   --sections          An alias for --section-headers
```

- [Beej's Quick Guide to GDB](http://beej.us/guide/bggdb/)

### macOS

```
objdump
dwarfdump
otool
```

## `include`

`gcc -v` show paths searched for `#include "..."` and `#include <...>`.
`#include` also works for files with a file extension name other than `.h`. For
exampl,e `#include "source.c"` also works. And the stuff inside `<>` or `""`
are pathname. Sor example, `#include <rock/lib.h>` works.

## C++ Trait
- [An introduction to C++ Traits](https://accu.org/index.php/journals/442)
- [细说 C++ Traits Classes](https://leehao.me/%E7%BB%86%E8%AF%B4-C-Traits-Classes/)

## Value Categories
- [Answer 1 What are rvalues, lvalues, xvalues, glvalues, and prvalues?](https://stackoverflow.com/a/38169963/431698)
- [Answer 2 What are rvalues, lvalues, xvalues, glvalues, and prvalues?](https://stackoverflow.com/a/3607179/431698)

Value properties:

- `i`: `has identity` – i.e. and address, a pointer, the user can determine whether two copies are identical, etc.
- `m`: `can be moved from` – i.e. we are allowed to leave to source of a "copy" in some indeterminate, but valid state

Value kinds:
- `iM`: has identity and cannot be moved from
- `im`: has identity and can be moved from (e.g. the result of casting an lvalue
  to a rvalue reference)
- `Im`: does not have identity and can be moved from.
- ~~`IM`: doesn’t have identity and cannot be moved) is not useful in C++ (or, I \
  think) in any other language.~~

```
             expression
            /        \
           /          \
    glvalue(i)       rvalue(m)
     /     \         /     \
    /       \       /       \
   /         \     /         \
lvalue(iM)   xvalue(im)     prvalue(Im)



    ______ ______
   /      X      \
  /      / \      \
 |   l  | x |  pr  |
  \      \ /      /
   \______X______/
       gl    r    
```

Value examples:
- lvalue: `*p`
- xvalue: `std::move`
- prvalue: `a + b`


## std::move
- [C++11 Tutorial: Introducing the Move Constructor and the Move Assignment Operator](https://blog.smartbear.com/c-plus-plus/c11-tutorial-introducing-the-move-constructor-and-the-move-assignment-operator/)

## Templates
- [What does template <unsigned int N> mean?](https://stackoverflow.com/a/499146/431698)
- [Understanding constexpr specifier in C++](https://www.geeksforgeeks.org/understanding-constexper-specifier-in-c/)

## Smart Pointer
- [Differences between unique_ptr and shared_ptr [duplicate](https://stackoverflow.com/a/6876833/431698)

## MISC
- [C++ auto& vs auto](https://stackoverflow.com/questions/29859796/c-auto-vs-auto)

Virtual:
- [virtual specifier is optional](http://en.cppreference.com/w/cpp/language/virtual):

[Google C++ Style Guide](https://google.github.io/styleguide/cppguide.html#Multiple_Inheritance) says:

> Explicitly annotate overrides of virtual functions or virtual destructors with exactly one of an override or (less frequently) final specifier. Do not use virtual when declaring an override. Rationale: A function or destructor marked override or final that is not an override of a base class virtual function will not compile, and this helps catch common errors. The specifiers serve as documentation; if no specifier is present, the reader has to check all ancestors of the class in question to determine if the function or destructor is virtual or not.

# Assembly
- [9.3.5.2 C Calling Convention](https://gcc.gnu.org/onlinedocs/gcc-5.2.0/gnat_ugn/C-Calling-Convention.html)
- [Introduction to x64 Assembly](https://software.intel.com/en-us/articles/introduction-to-x64-assembly)
- [9.15.3.1 AT&T Syntax versus Intel Syntax](https://sourceware.org/binutils/docs/as/i386_002dVariations.html#i386_002dVariations)
- [X86 psABI](https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI)
