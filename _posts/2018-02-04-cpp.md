---
layout: post
title: "C++"
description: ""
category:
tags: []
---
{% include JB/setup %}

- [Elements of Modern C++ Style](https://herbsutter.com/elements-of-modern-c-style/)
- [C++ POD](https://stackoverflow.com/a/146454/431698)

## C++ Trait
- [An introduction to C++ Traits](https://accu.org/index.php/journals/442)
- [细说 C++ Traits Classes](https://leehao.me/%E7%BB%86%E8%AF%B4-C-Traits-Classes/)

## Value Categories
- [Answer 1 What are rvalues, lvalues, xvalues, glvalues, and prvalues?](https://stackoverflow.com/a/38169963/431698)
- [Answer 2 What are rvalues, lvalues, xvalues, glvalues, and prvalues?](https://stackoverflow.com/a/3607179/431698)

Value properties:

- `i`: `has identity` – i.e. and address, a pointer, the user can determine whether two copies are identical, etc.
- `m`: `can be moved from` – i.e. we are allowed to leave to source of a "copy" in some indeterminate, but valid state

Value kinds:
- `iM`: has identity and cannot be moved from
- `im`: has identity and can be moved from (e.g. the result of casting an lvalue
  to a rvalue reference)
- `Im`: does not have identity and can be moved from.
- ~~`IM`: doesn’t have identity and cannot be moved) is not useful in C++ (or, I \
  think) in any other language.~~

```
             expression
            /        \
           /          \
    glvalue(i)       rvalue(m)
     /     \         /     \
    /       \       /       \
   /         \     /         \
lvalue(iM)   xvalue(im)     prvalue(Im)



    ______ ______
   /      X      \
  /      / \      \
 |   l  | x |  pr  |
  \      \ /      /
   \______X______/
       gl    r    
```

Value examples:
- lvalue: `*p`
- xvalue: `std::move`
- prvalue: `a + b`


## std::move
- [C++11 Tutorial: Introducing the Move Constructor and the Move Assignment Operator](https://blog.smartbear.com/c-plus-plus/c11-tutorial-introducing-the-move-constructor-and-the-move-assignment-operator/)

## Templates
- [What does template <unsigned int N> mean?](https://stackoverflow.com/a/499146/431698)
- [Understanding constexpr specifier in C++](https://www.geeksforgeeks.org/understanding-constexper-specifier-in-c/)

## Smart Pointer
- [Differences between unique_ptr and shared_ptr [duplicate](https://stackoverflow.com/a/6876833/431698)

## MISC
- [C++ auto& vs auto](https://stackoverflow.com/questions/29859796/c-auto-vs-auto)

Virtual:
- [virtual specifier is optional](http://en.cppreference.com/w/cpp/language/virtual):

> Explicitly annotate overrides of virtual functions or virtual destructors with exactly one of an override or (less frequently) final specifier. Do not use virtual when declaring an override. Rationale: A function or destructor marked override or final that is not an override of a base class virtual function will not compile, and this helps catch common errors. The specifiers serve as documentation; if no specifier is present, the reader has to check all ancestors of the class in question to determine if the function or destructor is virtual or not.
